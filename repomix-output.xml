This file is a merged representation of the entire codebase, combined into a single document by Repomix.

<file_summary>
This section contains a summary of this file.

<purpose>
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.
</purpose>

<file_format>
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Repository files (if enabled)
5. Multiple file entries, each consisting of:
  - File path as an attribute
  - Full contents of the file
</file_format>

<usage_guidelines>
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.
</usage_guidelines>

<notes>
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded
- Files are sorted by Git change count (files with more changes are at the bottom)
</notes>

</file_summary>

<directory_structure>
.gitignore
backend/.env.example
backend/.python-version
backend/app/db.py
backend/app/deps/auth.py
backend/app/libs/firebase_admin.py
backend/app/main.py
backend/app/routers/favorites.py
backend/app/routers/recipes.py
backend/app/routers/user.py
backend/app/schemas/favorite.py
backend/app/services/chatgpt_service.py
backend/app/services/recipe_service.py
backend/docker-compose.yml
backend/prisma/schema.prisma
backend/prisma/seed_users.py
backend/README.md
backend/requirements.txt
frontend/.env.example
frontend/.eslintignore
frontend/.eslintrc.json
frontend/.prettierignore
frontend/.prettierrc
frontend/next.config.js
frontend/package.json
frontend/postcss.config.js
frontend/public/google-icon.svg
frontend/README.md
frontend/src/app/api/fetchRecipes.ts
frontend/src/app/favorites/[id]/page.tsx
frontend/src/app/favorites/page.tsx
frontend/src/app/globals.css
frontend/src/app/layout.tsx
frontend/src/app/login/page.tsx
frontend/src/app/page.tsx
frontend/src/components/GoogleLoginButton.tsx
frontend/src/components/LoginMenu.tsx
frontend/src/components/PopupMessage.tsx
frontend/src/components/RecipeForm.tsx
frontend/src/components/RecipeList.tsx
frontend/src/libs/firebase.ts
frontend/src/libs/signInWithGoogle.ts
frontend/src/services/user.ts
frontend/src/utils/auth.ts
frontend/tailwind.config.js
frontend/tsconfig.eslint.json
frontend/tsconfig.json
README.md
</directory_structure>

<files>
This section contains the contents of the repository's files.

<file path="backend/app/db.py">
# app/db.py

from prisma import Prisma

prisma_client = Prisma()
</file>

<file path="backend/app/schemas/favorite.py">
# backend/app/schemas/favorite.py

from pydantic import BaseModel, Field

class FavoriteCreate(BaseModel):
    title: str = Field(..., max_length=50)
    content: str = Field(..., max_length=1000)
</file>

<file path="backend/app/services/recipe_service.py">
# backend/app/services/recipe_service.py

from app.db import prisma_client

async def get_all_recipes():
    recipes = await prisma_client.recipe.find_many()
    return recipes
</file>

<file path="frontend/.eslintignore">
node_modules
.next
dist
build
coverage
public
eslint.config.mjs
postcss.config.js
tailwind.config.js
</file>

<file path="frontend/.prettierignore">
node_modules
.next
dist
build
coverage
public
eslint.config.mjs
postcss.config.js
tailwind.config.js
</file>

<file path="frontend/.prettierrc">
{
  "semi": true,
  "singleQuote": true,
  "trailingComma": "es5",
  "printWidth": 80,
  "tabWidth": 2
}
</file>

<file path="frontend/postcss.config.js">
module.exports = {
  plugins: {
    tailwindcss: {},
    autoprefixer: {},
  },
};
</file>

<file path="frontend/public/google-icon.svg">
<?xml version="1.0" encoding="utf-8"?><!-- Uploaded to: SVG Repo, www.svgrepo.com, Generator: SVG Repo Mixer Tools -->
<svg width="800px" height="800px" viewBox="-3 0 262 262" xmlns="http://www.w3.org/2000/svg" preserveAspectRatio="xMidYMid"><path d="M255.878 133.451c0-10.734-.871-18.567-2.756-26.69H130.55v48.448h71.947c-1.45 12.04-9.283 30.172-26.69 42.356l-.244 1.622 38.755 30.023 2.685.268c24.659-22.774 38.875-56.282 38.875-96.027" fill="#4285F4"/><path d="M130.55 261.1c35.248 0 64.839-11.605 86.453-31.622l-41.196-31.913c-11.024 7.688-25.82 13.055-45.257 13.055-34.523 0-63.824-22.773-74.269-54.25l-1.531.13-40.298 31.187-.527 1.465C35.393 231.798 79.49 261.1 130.55 261.1" fill="#34A853"/><path d="M56.281 156.37c-2.756-8.123-4.351-16.827-4.351-25.82 0-8.994 1.595-17.697 4.206-25.82l-.073-1.73L15.26 71.312l-1.335.635C5.077 89.644 0 109.517 0 130.55s5.077 40.905 13.925 58.602l42.356-32.782" fill="#FBBC05"/><path d="M130.55 50.479c24.514 0 41.05 10.589 50.479 19.438l36.844-35.974C195.245 12.91 165.798 0 130.55 0 79.49 0 35.393 29.301 13.925 71.947l42.211 32.783c10.59-31.477 39.891-54.251 74.414-54.251" fill="#EB4335"/></svg>
</file>

<file path="frontend/README.md">
# レシピアプリ フロントエンド

## 💻 技術スタック

- Next.js
- TypeScript
- Tailwind CSS
- Firebase Authentication

## 🔧 開発環境のセットアップ

### 必要条件

- Node.js 18.x以上
- npm 9.x以上

### インストール手順

1. 依存関係のインストール

```bash
npm install
```

2. 環境変数の設定

```bash
cp .env.example .env.local
```

必要な環境変数:

- `NEXT_PUBLIC_API_BASE_URL`
- `NEXT_PUBLIC_FIREBASE_CONFIG_*`

3. 開発サーバーの起動

```bash
npm run dev
```

### スクリプト

- `npm run dev`: 開発サーバーの起動
- `npm run build`: プロダクションビルド
- `npm run lint`: ESLintによるコード検証
- `npm test`: テストの実行

## ディレクトリ構造

```
frontend/
├── src/
│   ├── app/         # ページコンポーネント
│   ├── api/         # APIクライアント
│   ├── components/  # 共通コンポーネント
│   ├── libs/        # ライブラリ初期化（Firebase等）
│   ├── services/    # ビジネスロジック
│   └── utils/       # ユーティリティ関数
└── public/          # 静的ファイル
```
</file>

<file path="frontend/src/app/favorites/[id]/page.tsx">
//お気に入り編集ページ
'use client'

import { useEffect, useState } from 'react'
import { useParams, useRouter } from 'next/navigation'
import { getIdToken } from '@/utils/auth'
import LoginMenuButton from '@/components/LoginMenu'

type Favorite = {
  id: string
  title: string
  content: string
}

export default function EditFavoritePage() {
  const { id } = useParams<{ id: string }>()
  const router = useRouter()

  const [favorite, setFavorite] = useState<Favorite | null>(null)
  const [title, setTitle] = useState('')
  const [content, setContent] = useState('')
  const [loading, setLoading] = useState(true)
  const [submitting, setSubmitting] = useState(false)
  const [error, setError] = useState<string | null>(null)

  // お気に入り1件取得
  const fetchFavorite = async () => {
    try {
      setLoading(true)
      const token = await getIdToken()
      if (!token) throw new Error('認証が必要です')

      const res = await fetch('http://localhost:8000/api/favorites', {
        headers: {
          Authorization: `Bearer ${token}`,
        },
      })

      const data: Favorite[] = await res.json()
      const target = data.find((item) => item.id === id)

      if (!target) {
        throw new Error('データが見つかりませんでした')
      }

      setFavorite(target)
      setTitle(target.title)
      setContent(target.content)
    } catch (err) {
      setError((err as Error).message)
    } finally {
      setLoading(false)
    }
  }

  useEffect(() => {
    fetchFavorite()
  }, [id])

  // 更新処理
  const handleUpdate = async () => {
    setSubmitting(true)
    try {
      const token = await getIdToken()
      if (!token) throw new Error('認証が必要です')

      const res = await fetch(`http://localhost:8000/api/favorites/${id}`, {
        method: 'PUT',
        headers: {
          'Content-Type': 'application/json',
          Authorization: `Bearer ${token}`,
        },
        body: JSON.stringify({ title, content }),
      })

      if (!res.ok) throw new Error('更新に失敗しました')

      router.push('/favorites')
    } catch (err) {
      setError((err as Error).message)
    } finally {
      setSubmitting(false)
    }
  }

  // 削除処理
  const handleDelete = async () => {
    if (!confirm('本当に削除しますか？')) return

    const token = await getIdToken()
    if (!token) return

    await fetch(`http://localhost:8000/api/favorites/${id}`, {
      method: 'DELETE',
      headers: {
        Authorization: `Bearer ${token}`,
      },
    })

    router.push('/favorites')
  }

  return (
    <div className="min-h-screen bg-white font-sans p-8 flex flex-col items-center gap-6">
      {/* ヘッダー */}
      <div className="flex justify-between w-full max-w-3xl items-center">
        <h1 className="text-3xl font-bold text-[#443627]">お気に入りを編集</h1>
        <LoginMenuButton />
      </div>

      {loading ? (
        <p className="text-gray-500">読み込み中...</p>
      ) : error ? (
        <p className="text-red-500">{error}</p>
      ) : (
        <div className="w-full max-w-3xl space-y-4">
          <input
            type="text"
            className="w-full px-4 py-2 border border-gray-300 rounded-md"
            value={title}
            onChange={(e) => setTitle(e.target.value)}
          />
          <textarea
            className="w-full px-4 py-2 border border-gray-300 rounded-md"
            value={content}
            onChange={(e) => setContent(e.target.value)}
          />
          <div className="flex gap-4">
            <button
              onClick={handleUpdate}
              disabled={submitting}
              className="bg-orange-400 hover:bg-orange-500 text-white px-4 py-2 rounded-md disabled:opacity-50"
            >
              {submitting ? '保存中...' : '更新する'}
            </button>
            <button
              onClick={handleDelete}
              className="bg-red-100 hover:bg-red-200 text-red-600 px-4 py-2 rounded-md"
            >
              削除する
            </button>
          </div>
          <button
            onClick={() => router.push('/favorites')}
            className="text-sm text-gray-500 hover:underline mt-2"
          >
            一覧に戻る
          </button>
        </div>
      )}
    </div>
  )
}
</file>

<file path="frontend/tsconfig.eslint.json">
{
  "extends": "./tsconfig.json",
  "include": [
    "src/**/*",
    "next-env.d.ts",
    "next.config.ts",
    "*.js",
    "*.ts",
    "**/*.ts",
    "**/*.tsx"
  ],
  "exclude": ["node_modules"]
}
</file>

<file path="backend/.python-version">
3.11.12
</file>

<file path="backend/app/routers/user.py">
# 内容: ユーザー情報を取得するAPIエンドポイント
from fastapi import APIRouter, Depends, HTTPException
from app.db import prisma_client
from app.deps.auth import get_current_user

router = APIRouter()


@router.get("/user")
async def get_current_user_profile(user=Depends(get_current_user)):
    db_user = await prisma_client.user.find_unique(where={"uid": user["uid"]})
    if not db_user:
        # 登録されていないユーザーの場合はエラーを返す
        raise HTTPException(status_code=403, detail="許可されていないユーザーです")
    return db_user
</file>

<file path="backend/README.md">
# レシピアプリ バックエンド

## 技術スタック

- FastAPI
- Prisma ORM
- PostgreSQL
- Firebase Admin SDK

## 開発環境のセットアップ

### 必要条件

- Python 3.11 以上
- PostgreSQL 14 以上
- pipenv

### インストール手順

1. 仮想環境を作成して有効化

```bash
python3.11.12 -m venv venv

# macOS/Linux
source venv/bin/activate
# Windows
venv\Scripts\activate
```

2. 依存パッケージのインストール

```bash
pip install -r requirements.txt
```

3. 環境変数の設定

```bash
cp .env.example .env
# .envファイルを編集して必要な環境変数を設定
```

4. データベースの起動

```bash
docker-compose up -d
```

5. Prisma のセットアップ

```bash
# 1. データベースマイグレーションを実行
npx prisma migrate dev --name init

# 2. Prismaクライアントの生成
prisma generate

# 3. 初期データの投入
python prisma/seed.py（例）
```

6. アプリケーションの起動

```bash
uvicorn app.main:app --reload
```

### API ドキュメント

<URL>

## 📁 ディレクトリ構造

```
backend/
├── app/
│   ├── routers/    # APIエンドポイント
│   ├── deps/       # 依存関係（認証等）
│   ├── libs/       # 共通ライブラリ
│   ├── schemas/    # リクエスト/レスポンスのデータモデル
│   └── services/   # ビジネスロジック
│
├── prisma/         # Prismaスキーマ・マイグレーション
└── venv/           # Python仮想環境
```

---
</file>

<file path="frontend/.env.example">
# 「ひな形」
# Firebase Config
NEXT_PUBLIC_FIREBASE_API_KEY=your_firebase_api_key
NEXT_PUBLIC_FIREBASE_AUTH_DOMAIN=your_project.firebaseapp.com
NEXT_PUBLIC_FIREBASE_PROJECT_ID=your_project_id
NEXT_PUBLIC_FIREBASE_STORAGE_BUCKET=your_project.appspot.com
NEXT_PUBLIC_FIREBASE_MESSAGING_SENDER_ID=your_messaging_sender_id
NEXT_PUBLIC_FIREBASE_APP_ID=your_app_id

# API Base URL
NEXT_PUBLIC_API_BASE_URL=http://localhost:xxxx
</file>

<file path="frontend/.eslintrc.json">
{
  "env": {
    "browser": true,
    "es2022": true,
    "node": true
  },
  "extends": [
    "airbnb",
    "plugin:@typescript-eslint/recommended",
    "airbnb-typescript",
    "next/core-web-vitals",
    "plugin:prettier/recommended"
  ],
  "parser": "@typescript-eslint/parser",
  "parserOptions": {
    "project": "./tsconfig.eslint.json",
    "sourceType": "module"
  },
  "plugins": ["@typescript-eslint", "prettier", "import"],
  "rules": {
    "prettier/prettier": "error",
    "import/extensions": [
      "error",
      "ignorePackages",
      {
        "js": "never",
        "jsx": "never",
        "ts": "never",
        "tsx": "never"
      }
    ],
    "@typescript-eslint/no-unused-vars": ["error", { "argsIgnorePattern": "^_" }],
    "no-console": "warn"
  },
  "settings": {
    "import/resolver": {
      "node": {
        "extensions": [".js", ".jsx", ".ts", ".tsx"]
      },
      "typescript": {}
    }
  },
  "ignorePatterns": ["prettier.config.js"]
}
</file>

<file path="frontend/src/app/api/fetchRecipes.ts">
async function fetchRecipes(
  keyword: string
): Promise<{ title: string; instructions: string }[]> {
  const response = await fetch('http://localhost:8000/api/recipes', {
    method: 'POST',
    headers: { 'Content-Type': 'application/json' },
    body: JSON.stringify({ keyword }),
  });

  if (!response.ok) {
    throw new Error('レシピ取得に失敗しました');
  }

  const data = await response.json();

  // ⭐ ここに入れる！！(本番では削除)
  console.log('API response:', data);

  // FastAPI 側が { recipes: [{ title, instructions }, ...] } を返している場合
  return data.recipe;
}

export default fetchRecipes;
</file>

<file path="frontend/src/app/favorites/page.tsx">
//一覧ページ
'use client'

import { useEffect, useState } from 'react'
import { getIdToken } from '@/utils/auth'
import LoginMenuButton from '@/components/LoginMenu'

type Favorite = {
  id: string
  title: string
  content: string
}

export default function FavoritesPage() {
  const [favorites, setFavorites] = useState<Favorite[]>([])
  const [loading, setLoading] = useState(true)
  const [error, setError] = useState<string | null>(null)

  const fetchFavorites = async () => {
    try {
      setLoading(true)
      setError(null)

      const token = await getIdToken()
      if (!token) {
        throw new Error('認証トークンが取得できません')
      }

      const res = await fetch('http://localhost:8000/api/favorites', {
        headers: {
          Authorization: `Bearer ${token}`,
        },
      })

      if (!res.ok) {
        throw new Error(`エラーが発生しました (${res.status})`)
      }

      const data = await res.json()
      setFavorites(data)
    } catch (err) {
      setError((err as Error).message)
    } finally {
      setLoading(false)
    }
  }

  useEffect(() => {
    fetchFavorites()
  }, [])

  return (
    <div className="min-h-screen bg-white font-sans p-8 flex flex-col items-center gap-6">
      {/* ヘッダー */}
      <div className="flex justify-between w-full max-w-3xl items-center">
        <h1 className="text-3xl font-bold text-[#443627]">お気に入り一覧</h1>
        <LoginMenuButton />
      </div>

      {loading && <p className="text-gray-500">読み込み中...</p>}
      {error && <p className="text-red-500">{error}</p>}

      {/* お気に入りリスト */}
      <div className="w-full max-w-3xl space-y-4">
        {favorites.length === 0 && !loading ? (
          <p className="text-gray-400 text-center">お気に入りはまだ登録されていません。</p>
        ) : (
          favorites.map((fav) => (
            <div
              key={fav.id}
              className="border rounded-lg p-4 bg-white shadow-sm"
            >
              <h2 className="text-xl font-semibold text-[#443627]">{fav.title}</h2>
              <p className="text-gray-600 mt-1 whitespace-pre-wrap">{fav.content}</p>
            </div>
          ))
        )}
      </div>
    </div>
  )
}
</file>

<file path="frontend/src/components/PopupMessage.tsx">
'use client';

import { useEffect } from 'react';

type PopupMessageProps = {
  message: string;
  onClose: () => void;
  autoClose: boolean;
  autoCloseDelay: number;
};

export default function PopupMessage({
  message,
  onClose,
  autoClose = false,
  autoCloseDelay = 3000,
}: PopupMessageProps) {
  // 自動クローズ処理
  useEffect(() => {
    if (autoClose && onClose) {
      const timer = setTimeout(onClose, autoCloseDelay);
      return () => clearTimeout(timer); // クリーンアップ
    }
    return undefined; // 何もしない場合は明示的にundefinedを返す
  }, [autoClose, autoCloseDelay, onClose]);

  return (
    <div className="fixed top-0 left-0 w-full h-full bg-black bg-opacity-50 flex justify-center items-center z-50">
      <div className="bg-white p-8 rounded shadow text-center">
        <p>{message}</p>
        {!autoClose && (
          <button
            onClick={onClose}
            className="mt-4 px-4 py-2 bg-blue-500 text-white rounded"
            type="button"
          >
            OK
          </button>
        )}
      </div>
    </div>
  );
}
</file>

<file path="frontend/src/libs/signInWithGoogle.ts">
import { signInWithPopup } from 'firebase/auth';
import { auth, googleProvider } from '@/libs/firebase';

// Googleログイン処理。ログイン結果を返す
const signInWithGoogle = async () => {
  const result = await signInWithPopup(auth, googleProvider);
  return result;
};

export default signInWithGoogle;
</file>

<file path="frontend/src/services/user.ts">
import getIdToken from '@/utils/auth';

// 認証付きでユーザー情報を取得する関数
export default async function fetchUser() {
  const idToken = await getIdToken();
  const res = await fetch(`${process.env.NEXT_PUBLIC_API_URL}/user`, {
    headers: {
      Authorization: `Bearer ${idToken}`,
    },
  });
  if (!res.ok) throw new Error('認証失敗');
  return res.json(); // return await を return だけに修正
}
</file>

<file path="frontend/tsconfig.json">
{
  "compilerOptions": {
    "target": "ES2022",
    "lib": ["dom", "dom.iterable", "esnext"],
    "allowJs": true,
    "skipLibCheck": true,
    "strict": true,
    "noEmit": true,
    "esModuleInterop": true,
    "module": "esnext",
    "moduleResolution": "bundler",
    "resolveJsonModule": true,
    "isolatedModules": true,
    "jsx": "preserve",
    "incremental": true,
    "types": ["vitest/globals", "node"],
    "plugins": [
      {
        "name": "next"
      }
    ],
    "paths": {
      "@/*": ["./src/*"]
    }
  },
  "include": ["next-env.d.ts", "**/*.ts", "**/*.tsx", ".next/types/**/*.ts"],
  "exclude": ["node_modules", ".next"]
}
</file>

<file path="README.md">
# レシピ管理アプリケーション

## 概要

このプロジェクトは、AI を活用してユーザーの冷蔵庫の食材からレシピを提案し、お気に入りのレシピを管理・共有できる Web アプリケーションです。

## 🌟 実装機能一覧（MVP）

1. 🧂 **レシピ提案機能**

   - 材料を入力すると、ChatGPT が最適なレシピを提案
   - 季節や調理時間を考慮したレシピ生成

2. 👤 **ユーザー管理機能**
   - Google アカウントでの簡単ログイン
   - ユーザープロフィールの管理
3. ⭐ **お気に入り機能**
   - 気に入ったレシピの保存
   - お気に入りレシピの一覧表示と検索
   - レシピの編集と削除

## 💻 技術スタック

### フロントエンド

- Next.js 13 (App Router)
- TypeScript 5.3
- Tailwind CSS 3.4
- Firebase Authentication

### バックエンド

- FastAPI 0.104
- Python 3.11
- Prisma Client Python
- Firebase Admin SDK

### インフラ・外部サービス

- PostgreSQL 14
- Docker / docker-compose
- OpenAI API (GPT-4)
- Firebase Authentication

## 📂 ディレクトリ構造

```
section7_teamB/
├── frontend/     # フロントエンドアプリケーション
├── backend/      # バックエンドAPI
└── docs/         # プロジェクトドキュメント
```

## 🔧 開発環境のセットアップ

1. リポジトリのクローン

```bash
git clone https://github.com/ms-engineer-bc25-04/section7_teamB.git
cd section7_teamB
```

2. 環境変数の設定

- `.env.example`をコピーして`.env`を作成
- 必要な環境変数を設定

3. フロントエンドとバックエンドの起動

- 詳細は各ディレクトリの README を参照

## ライセンス

MIT License
</file>

<file path="backend/app/deps/auth.py">
"""Authentication dependency module."""  # C0114対策
# Firebase の ID トークン認証用ミドルウェア
# APIリクエストのAuthorizationヘッダーからIDトークンを抽出し検証する

from fastapi import HTTPException, Security
from fastapi.security import HTTPBearer, HTTPAuthorizationCredentials
from app.libs.firebase_admin import initialize_firebase
from firebase_admin import auth as firebase_auth

# Bearer認証のスキーマを設定
security = HTTPBearer()

async def get_current_user(token: HTTPAuthorizationCredentials = Security(security)):
    """
    Firebase の ID トークンを検証し、認証済みユーザー情報（デコード済みトークン）を返す
    """
    try:
        print("受け取ったトークン:", token.credentials)  # 追加
        # Authorizationヘッダーからトークンを抽出し、Firebaseで検証
        decoded_token = firebase_auth.verify_id_token(token.credentials)
        print("デコード後:", decoded_token)  # 追加
        return decoded_token
    except Exception as e:
        print("認証エラー:", e)
        raise HTTPException(status_code=401, detail="認証に失敗しました")
</file>

<file path="backend/app/libs/firebase_admin.py">
"""Firebase Admin SDK initialization helper module."""  # C0114対策
# Firebase Admin SDK の初期化

import os
from pathlib import Path
import firebase_admin
from firebase_admin import credentials
from fastapi import HTTPException


def initialize_firebase():
    """Initialize Firebase Admin SDK if not already initialized."""  # C0116対策
    # テスト中は Firebase 初期化をスキップ
    if os.getenv("TESTING") == "1":
        print("[INFO] Skipping Firebase initialization (TESTING mode)")
        return

    try:
        # サービスアカウントキーのパスを環境変数から取得
        cred_path = os.environ.get(
            "FIREBASE_ADMIN_KEY_PATH", "./serviceAccountKey.json"
        )
        if not Path(cred_path).exists():
            raise FileNotFoundError(
                f"Firebase credentials file not found at {cred_path}"
            )

        # Firebaseアプリが未初期化なら初期化する
        if not firebase_admin._apps:
            cred = credentials.Certificate(cred_path)
            firebase_admin.initialize_app(cred)
    except Exception as e:
        raise HTTPException(
            status_code=500, detail=f"Firebase initialization failed: {str(e)}"
        )


# FastAPIアプリ起動時に呼び出し
initialize_firebase()
</file>

<file path="backend/app/routers/recipes.py">
from fastapi import APIRouter
from pydantic import BaseModel
from app.services import chatgpt_service

router = APIRouter()

# リクエストのBody用のSchema
class RecipeRequest(BaseModel):
    keyword: str

# POST /api/recipes
@router.post("")
async def create_recipe(request: RecipeRequest):
    keyword = request.keyword
    # await を外す → 同期関数だから
    recipe = chatgpt_service.get_recipe_from_chatgpt(keyword)
    return {"recipe": recipe}
</file>

<file path="backend/app/services/chatgpt_service.py">
import os
import openai

# OpenAI APIキーを環境変数から取得
openai.api_key = os.getenv("OPENAI_API_KEY")

# ChatGPT からレシピを取得する関数
def get_recipe_from_chatgpt(keyword: str) -> list:
    prompt = f"""
    あなたはプロの料理研究家です。
    次の材料「{keyword}」を使った料理を2つ提案してください。
    以下の形式で、必ず **JSON形式** で返してください（文章は不要です）：
    "instructions" は **各手順を改行（\\n）で区切ってください**。

    {{
        "recipes": [
        {{
            "title": "レシピタイトル1",
            "instructions": "1. 手順1\\n2. 手順2\\n3. 手順3"
        }},
        {{
            "title": "レシピタイトル2",
            "instructions": "1. 手順1\\n2. 手順2\\n3. 手順3"
        }}
        ]
    }}
    """

    response = openai.chat.completions.create(
        model="gpt-4o-mini",
        messages=[
            {"role": "user", "content": prompt}
        ],
        max_tokens=500,
        temperature=0.7,
    )

    # レスポンスから content を取り出す
    recipe_text = response.choices[0].message.content

    # JSON部分を辞書に変換
    import json
    try:
        recipe_json = json.loads(recipe_text)
        return recipe_json["recipes"]
    except Exception as e:
        print("JSON parse error:", e)
        print("Response was:", recipe_text)
        # エラー時は空リストを返す
        return []
</file>

<file path="backend/prisma/seed_users.py">
import asyncio
from prisma import Prisma
from prisma.types import UserCreateInput

USERS = [
    UserCreateInput(
        uid="LGr43wiqwqXN0rcy6nmbFaQpWiz2",
        email="takaeshiobara@gmail.com",
        name="takae",
    ),
    UserCreateInput(
        uid="QAUq4FlFB6deuhVMRD77btxZ4zz1", 
        email="r15.zzz0415@gmail.com",   
        name="noriko",
    ),
]


async def main():
    db = Prisma()
    await db.connect()
    for user in USERS:
        # uidが重複しないようにチェック
        exists = await db.user.find_unique(where={"uid": user["uid"]})
        if not exists:
            await db.user.create(data=user)
    await db.disconnect()


if __name__ == "__main__":
    asyncio.run(main())
</file>

<file path="frontend/src/app/globals.css">
@tailwind base;
@tailwind components;
@tailwind utilities;

:root {
  --color-primary: #393E46;
  --color-button-white: #FFFFFF;
  --color-button-orange: #FF9D23;
  --color-title: #443627;
  --color-text: #393E46;
  --color-background: #FFFFFF;
}

body {
  @apply bg-background text-text font-sans;
}
</file>

<file path="frontend/src/app/layout.tsx">
import type { Metadata } from 'next';
import './globals.css';
import { Toaster } from 'react-hot-toast';

// Tailwindのfont-sansを使用するため、Google Fontsの設定は削除しました

export const metadata: Metadata = {
  title: 'レシピ提案アプリ', // プロジェクトタイトルを設定
  description: 'あなたの冷蔵庫の食材から簡単レシピを提案するWebアプリ', // プロジェクト説明を設定
};

export default function RootLayout({
  children,
}: Readonly<{
  children: React.ReactNode;
}>) {
  return (
    <html lang="ja">
      <body
        className="font-sans antialiased" // Tailwindのフォントとアンチエイリアス（文字や画像の縁をなめらかに補正する技術）を適用
      >
        <Toaster />
        {children}
      </body>
    </html>
  );
}
</file>

<file path="frontend/src/components/LoginMenu.tsx">
import { useState, useRef, useEffect } from 'react';
import { useAuthState } from 'react-firebase-hooks/auth';
import { auth } from '@/libs/firebase';
import { useRouter } from 'next/navigation';
import toast from 'react-hot-toast';

export default function LoginMenuButton() {
  const [user] = useAuthState(auth);
  const [open, setOpen] = useState(false);
  const router = useRouter();

  // ドロップダウンメニュー用のref
  const menuRef = useRef<HTMLDivElement>(null);

  // 外側クリックでドロップダウンを閉じる
  useEffect(() => {
    function handleClickOutside(event: MouseEvent) {
      if (menuRef.current && !menuRef.current.contains(event.target as Node)) {
        setOpen(false);
      }
    }
    if (open) {
      document.addEventListener('mousedown', handleClickOutside);
    }
    return () => {
      document.removeEventListener('mousedown', handleClickOutside);
    };
  }, [open]);

  // ログアウト処理
  const handleLogout = async () => {
    await auth.signOut();
    toast.success('ログアウトしました！');
    setTimeout(() => {
      router.push('/');
    }, 700);
  };

  if (!user) {
    // 未ログイン時は「ログイン」ボタン（やわらかいオレンジ・丸み）
    return (
      <button
        type="button" // 明示的にtypeを指定（form誤動作防止）
        onClick={() => router.push('/login')}
        className="px-4 py-2 rounded-full bg-orange-400 text-white font-semibold hover:bg-orange-500 transition"
        style={{ boxShadow: '0 1px 3px #f2e3c6' }}
      >
        ログイン
      </button>
    );
  }

  // ログイン時は丸い共通アイコン＋ドロップダウンメニュー
  return (
    <div className="relative">
      <button
        type="button" // 明示的にtypeを指定（form誤動作防止）
        onClick={() => setOpen((v) => !v)}
        className="w-10 h-10 rounded-full bg-orange-100 flex items-center justify-center hover:bg-orange-200 transition relative"
        title="ログイン中"
        style={{ border: '2px solid #f59e42' }}
      >
        {/* 共通の人型アイコン（SVG） */}
        <svg width="26" height="26" viewBox="0 0 24 24" fill="none">
          <circle cx="12" cy="12" r="12" fill="#F9D7A0" />
          <path
            d="M12 13c2.7 0 4.5 1.2 4.5 2.3v1.2H7.5v-1.2C7.5 14.2 9.3 13 12 13Zm0-1.5a2.25 2.25 0 1 0 0-4.5 2.25 2.25 0 0 0 0 4.5Z"
            fill="#F59E42"
          />
        </svg>
        {/* 緑の小さいバッジ */}
        <span className="absolute right-0 bottom-0 block w-3 h-3 rounded-full bg-green-400 border-2 border-white" />
      </button>
      {/* ドロップダウンメニュー */}
      {open && (
        <div className="absolute right-0 mt-2 w-40 bg-white rounded-lg border border-orange-200 shadow-md z-50">
          <button
            type="button"
            className="block w-full px-4 py-2 hover:bg-orange-50 text-left text-gray-700"
            onClick={() => {
              setOpen(false);
              router.push('/');
            }}
          >
            トップ
          </button>
          <button
            type="button"
            className="block w-full px-4 py-2 hover:bg-orange-50 text-left text-gray-700"
            onClick={() => {
              setOpen(false);
              router.push('/favorites');
            }}
          >
            お気に入り
          </button>
          <button
            type="button"
            className="block w-full px-4 py-2 hover:bg-orange-100 text-left text-orange-500"
            onClick={handleLogout}
          >
            ログアウト
          </button>
        </div>
      )}
    </div>
  );
}
</file>

<file path="frontend/src/components/RecipeForm.tsx">
'use client';

import { useState } from 'react';

type RecipeFormProps = {
  onSearch: (ingredients: string[]) => void;
};

export default function RecipeForm({ onSearch }: RecipeFormProps) {
  const [ingredient1, setIngredient1] = useState('');
  const [ingredient2, setIngredient2] = useState('');
  const [ingredient3, setIngredient3] = useState('');

  const handleSubmit = (e: React.FormEvent) => {
    e.preventDefault();
    onSearch([ingredient1, ingredient2, ingredient3]);
  };

  return (
    <form
      onSubmit={handleSubmit}
      className="mb-4 flex flex-col gap-2 items-center"
    >
      {/* ユーザーに表示するラベルは1つだけ */}
      <label htmlFor="ingredient1" className="text-[#443627] font-bold">
        📝 食材を入力してください
        <input
          id="ingredient1"
          type="text"
          value={ingredient1}
          onChange={(e) => setIngredient1(e.target.value)}
          placeholder="食材1"
          className="border p-2 rounded text-[#393E46] w-64"
        />
      </label>
      {/* アクセシビリティ対応（見た目は非表示、スクリーンリーダーのみ読まれる） */}
      <label htmlFor="ingredient2" className="sr-only">
        食材2を入力してください
        <input
          id="ingredient2"
          type="text"
          value={ingredient2}
          onChange={(e) => setIngredient2(e.target.value)}
          placeholder="食材2"
          className="border p-2 rounded text-[#393E46] w-64"
        />
      </label>
      <label htmlFor="ingredient3" className="sr-only">
        食材3を入力してください
        <input
          id="ingredient3"
          type="text"
          value={ingredient3}
          onChange={(e) => setIngredient3(e.target.value)}
          placeholder="食材3"
          className="border p-2 rounded text-[#393E46] w-64"
        />
      </label>
      <button
        type="submit"
        className="bg-[#FF9D23] text-white px-4 py-2 rounded hover:bg-orange-400 mt-2"
      >
        レシピを提案する
      </button>
    </form>
  );
}
</file>

<file path="frontend/src/components/RecipeList.tsx">
// src/components/RecipeList.tsx

type Recipe = {
  title: string;
  instructions: string;
};

type RecipeListProps = {
  recipes: Recipe[];
  addFavorite: (recipe: Recipe) => void;
  isSubmitting: boolean;
};

export default function RecipeList({
  recipes,
  addFavorite,
  isSubmitting,
}: RecipeListProps) {
  if (recipes.length === 0) {
    return <p>レシピはまだ表示されていません。</p>;
  }

return (
    <div className="flex flex-col gap-4">
      {recipes.map((recipe, index) => (
        <div
          key={index}
          className="border p-4 rounded bg-white shadow flex flex-col gap-2"
        >
          <div className="flex items-center gap-2">
            <span>🔍</span>
            <h2 className="text-lg font-bold text-[#443627]">{recipe.title}</h2>
          </div>
          {/* ここを preタグにする！ */}
          <pre className="whitespace-pre-wrap text-left text-[#393E46]">{recipe.instructions}</pre>
          
           <button
            onClick={() => addFavorite(recipe)}
            disabled={isSubmitting}
            className="mt-2 px-4 py-2 border text-[#FF9D23] border-[#FF9D23] rounded transition hover:bg-[#FFF3E0] disabled:opacity-50"
          >
            {isSubmitting ? '登録中...' : '★ お気に入りに追加'}
          </button>

        </div>
      ))}
    </div>
  );
}
</file>

<file path="frontend/tailwind.config.js">
/** @type {import('tailwindcss').Config} */
module.exports = {
  content: [
    './src/**/*.{js,ts,jsx,tsx}',
  ],
  theme: {
    extend: {
      colors: {
        primary: 'var(--color-primary)',
        button: {
          white: 'var(--color-button-white)',
          orange: 'var(--color-button-orange)',
        },
        title: 'var(--color-title)', // タイトル用 茶色
        text: 'var(--color-text)', // テキスト用 灰黒色
        background: 'var(--color-background)', // 背景用ホワイト
      },
      fontFamily: {
        // 日本語対応フォント
        sans: ['"Yu Gothic Medium"', 'sans-serif'],
      },
    },
  },
  plugins: [],
};
</file>

<file path="backend/.env.example">
# 「ひな形」
DATABASE_URL=postgresql://postgres:password@db:5432/myapp_db
OPENAI_API_KEY=your_openai_api_key
FIREBASE_PROJECT_ID=your_project_id
ALLOWED_ORIGINS=http://localhost:xxxx
</file>

<file path="backend/requirements.txt">
# FastAPI 本体
fastapi==0.104.10

# ASGI サーバー（開発用）
uvicorn[standard]==0.24.0


# 環境変数管理
python-dotenv==1.0.0

# OpenAI API 用
openai==1.3.5

# Firebase 認証
firebase-admin==6.2.0

# Prisma Python Client（Prisma導入済み前提）
prisma==0.11.0

# テスト系
pytest==7.4.0
pytest-asyncio==0.21.1
httpx==0.25.0

fastapi
uvicorn[standard]
python-dotenv
prisma
</file>

<file path="frontend/next.config.js">
/** @type {import('next').NextConfig} */
const nextConfig = {
  reactStrictMode: true,
};

module.exports = nextConfig;
</file>

<file path="frontend/src/libs/firebase.ts">
// Firebase関連のライブラリをインポート
import { initializeApp, getApps } from 'firebase/app'; // Firebaseアプリの初期化・取得
import { getAuth, GoogleAuthProvider } from 'firebase/auth'; // 認証関連の関数・クラス

// Firebaseプロジェクトの設定情報（環境変数から取得）
const firebaseConfig = {
  apiKey: process.env.NEXT_PUBLIC_FIREBASE_API_KEY ?? '',
  authDomain: process.env.NEXT_PUBLIC_FIREBASE_AUTH_DOMAIN ?? '',
  projectId: process.env.NEXT_PUBLIC_FIREBASE_PROJECT_ID ?? '',
  storageBucket: process.env.NEXT_PUBLIC_FIREBASE_STORAGE_BUCKET ?? '',
  messagingSenderId: process.env.NEXT_PUBLIC_FIREBASE_MESSAGING_SENDER_ID ?? '',
  appId: process.env.NEXT_PUBLIC_FIREBASE_APP_ID ?? '',
};

// Firebaseアプリの初期化（すでに初期化済みの場合は再利用）
// サーバーサイドレンダリングやHotReload時の二重初期化を防ぐための実装
const app = !getApps().length
  ? initializeApp(firebaseConfig) // まだ初期化されていなければ初期化
  : getApps()[0]; // 既存のappインスタンスがあればそれを使う

// Firebase認証機能のインスタンスを取得・エクスポート
export const auth = getAuth(app);

// Google認証プロバイダーを作成・エクスポート
export const googleProvider = new GoogleAuthProvider();
// Googleログイン時、毎回アカウント選択画面を表示するようパラメータを設定
googleProvider.setCustomParameters({ prompt: 'select_account' });

// 初期化したFirebaseアプリのインスタンスをデフォルトエクスポート
export default app;
</file>

<file path="frontend/src/utils/auth.ts">
import { auth } from '@/libs/firebase';

// FirebaseのIDトークンを取得するユーティリティ関数
export default async function getIdToken(): Promise<string | null> {
  const user = auth.currentUser;
  if (!user) {
    console.warn(
      'Firebaseユーザーが見つかりません。ログインしていない可能性があります。'
    );
    return null;
  }
  return user.getIdToken();
}
</file>

<file path=".gitignore">
# Dependencies
**/node_modules/
**/venv/
**/.venv/

# Environment
**/.env
**/.env.*
!**/.env.example

# Python
**/__pycache__/
**/*.py[cod]
**/*.so

# Database
**/db-data/
**/prisma/migrations/
**/generated/prisma
**/*.sqlite
**/*.db

# Build outputs
**/.next/
**/build/
**/dist/

# Firebase
**/serviceAccountKey.json

# typescript
**/*.tsbuildinfo
**/next-env.d.ts

# IDE
.vscode/
**/.vscode/

# OS generated
.DS_Store
**/.DS_Store
*.pem
Thumbs.db

# Testing
coverage/
.coverage
htmlcov/
</file>

<file path="backend/prisma/schema.prisma">
// This is your Prisma schema file,
// learn more about it in the docs: https://pris.ly/d/prisma-schema

// Looking for ways to speed up your queries, or scale easily with your serverless or edge functions?
// Try Prisma Accelerate: https://pris.ly/cli/accelerate-init

generator client {
  provider = "prisma-client-py"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

model User {
  id        String     @id @default(cuid())
  uid       String     @unique
  email     String     @unique
  name      String?
  createdAt DateTime   @default(now())
  updatedAt DateTime   @updatedAt
  favorites Favorite[] @relation("UserFavorites")

  @@map("users")
}

model Favorite {
  id        String   @id @default(cuid())
  title     String
  content   String
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
  userUid   String
  user      User     @relation("UserFavorites", fields: [userUid], references: [uid], onDelete: Cascade)

  @@map("favorites")
}
</file>

<file path="backend/app/routers/favorites.py">
"""Favorites router module"""  # C0114対策
from fastapi import APIRouter, HTTPException, Path, Body, Depends
from pydantic import BaseModel
from app.db import prisma_client
from app.deps.auth import get_current_user


router = APIRouter()


# お気に入り新規登録時のリクエストボディ
class FavoriteCreateRequest(BaseModel):
    """Request model for creating favorite"""  # C0115対策
    title: str
    content: str


# お気に入り更新時のリクエストボディ
class FavoriteUpdateRequest(BaseModel):
    """Request model for updating favorite"""  # C0115対策
    title: str
    content: str


# 認証済みユーザーのお気に入り一覧取得
@router.get("")
async def read_favorites(user=Depends(get_current_user)):
    """Get the list of favorites for the authenticated user"""  # C0116対策
    # uidで絞る
    favorites = await prisma_client.favorite.find_many(where={"userUid": user["uid"]})
    return favorites


# 認証済みユーザーのお気に入りを新規登録 (POST)
@router.post("")
async def create_favorite(
    favorite_data: FavoriteCreateRequest = Body(...),
    user=Depends(get_current_user),
):
    """Create a new favorite for the authenticated user"""  # C0116対策
    # タイトルだけで重複チェック
    existing_favorite = await prisma_client.favorite.find_first(
        where={
            "userUid": user["uid"],
            "title": favorite_data.title,
            }
        )
    if existing_favorite:
        raise HTTPException(status_code=409, detail="Duplicate favorite")

    # 新規登録
    created_favorite = await prisma_client.favorite.create(
        data={
            "title": favorite_data.title,
            "content": favorite_data.content,
            "userUid": user["uid"],  # ← 認証ユーザーのuidをセット
            }
        )
    return created_favorite


# 認証済みユーザーのお気に入りを更新 (PUT)
@router.put("/{favorite_id}")
async def update_favorite(
     favorite_id: str = Path(..., description="編集するお気に入りのID"),
     favorite_data: FavoriteUpdateRequest = Body(...),
     user=Depends(get_current_user),
     ):
    """Update an existing favorite"""  # C0116対策
    # 該当ID＋自分のデータのみ
    favorite = await prisma_client.favorite.find_unique(where={"id": favorite_id})
    if not favorite or favorite.userUid != user["uid"]:
        raise HTTPException(status_code=404, detail="Favorite not found or not yours")

    # データを更新
    return await prisma_client.favorite.update(
        where={"id": favorite_id},
        data={"title": favorite_data.title, "content": favorite_data.content},
        )


# 認証済みユーザーのお気に入りを削除(delete)
@router.delete("/{favorite_id}")
async def delete_favorite(
    favorite_id: str = Path(..., description="削除するお気に入りのID"),
    user = Depends(get_current_user),
):
    """Delete an existing favorite"""  # C0116対策
    _ = user  # W0613対策 → ダミーで「使った」扱いにする
    favorite = await prisma_client.favorite.find_unique(where={"id": favorite_id})
    if not favorite:
        raise HTTPException(status_code=404, detail="Favorite not found")
    await prisma_client.favorite.delete(where={"id": favorite_id})
    return {"message": "Favorite deleted successfully"}
</file>

<file path="backend/docker-compose.yml">
version: '3.8'
services:
  postgres:
    image: postgres:14
    container_name: myapp_postgres
    environment:
      POSTGRES_USER: postgres
      POSTGRES_PASSWORD: postgres
      POSTGRES_DB: myapp_db
    ports:
      - "5432:5432"
    volumes:
      - postgres_data:/var/lib/postgresql/data

volumes:
  postgres_data:
</file>

<file path="frontend/src/components/GoogleLoginButton.tsx">
import { useState } from 'react';
import { auth, googleProvider } from '@/libs/firebase';
import { signInWithPopup } from 'firebase/auth';
import { useRouter } from 'next/navigation';
import Image from 'next/image';
import toast from 'react-hot-toast';

export default function GoogleLoginButton() {
  const [isLoading, setIsLoading] = useState(false);
  const [error, setError] = useState<string | null>(null); // エラー表示用state
  const router = useRouter();

  const handleLogin = async () => {
    setIsLoading(true);
    setError(null); // 前のエラーをクリア
    try {
      // Google認証ポップアップ表示
      const result = await signInWithPopup(auth, googleProvider);
      // Firebase IDトークンを取得
      const idToken = await result.user.getIdToken();
      // /api/user に認証付きでアクセス
      const baseUrl = process.env.NEXT_PUBLIC_API_BASE_URL;
      const res = await fetch(`${baseUrl}/user`, {
        headers: {
          Authorization: `Bearer ${idToken}`,
        },
      });

      if (res.ok) {
        toast.success('ログイン成功！');
        setTimeout(() => {
          router.push('/favorites');
        }, 700);
      } else {
        const err = await res.json();
        setError(`認証エラー: ${err.detail}`); // ここでエラーstateにセット
      }
    } catch (err) {
      setError('Googleログインに失敗しました。再度お試しください。');
    } finally {
      setIsLoading(false);
    }
  };

  return (
    <>
      {/* エラーがあればボタン上部に表示 */}
      {error && (
        <div className="mb-2 text-red-600 bg-red-50 border border-red-300 rounded p-2">
          {error}
        </div>
      )}
      <button
        type="button"
        onClick={handleLogin}
        disabled={isLoading}
        className="flex items-center justify-center gap-2 w-64 py-3 px-6 rounded-full bg-orange-400 hover:bg-orange-500 text-white text-base font-semibold transition shadow mb-2"
        style={{ boxShadow: '0 1px 3px #f2e3c6' }}
      >
        {isLoading ? (
          <span>ログイン中...</span>
        ) : (
          <>
            <Image src="/google-icon.svg" alt="Google" width={24} height={24} />
            <span>Googleでログイン</span>
          </>
        )}
      </button>
    </>
  );
}
</file>

<file path="backend/app/main.py">
from fastapi import FastAPI
from fastapi.middleware.cors import CORSMiddleware
from dotenv import load_dotenv
import os



# ルーターの import
from app.routers import recipes, favorites, user

# Prisma Client を使うための import
from app.db import prisma_client

# .envファイルから環境変数を読み込む
load_dotenv()

# FastAPIアプリケーションのインスタンス生成
app = FastAPI(title="Recipe App API", version="1.0.0")

# CORS設定（フロントエンドのNext.jsなどと連携するため）
origins = os.getenv("ALLOWED_ORIGINS", "").split(",")
app.add_middleware(
    CORSMiddleware,
    allow_origins=origins,  # 許可するオリジン
    allow_credentials=True,
    allow_methods=["*"],  # 全メソッド許可
    allow_headers=["*"],  # 全ヘッダー許可
)


# Prisma Client の接続・切断イベントを追加
@app.on_event("startup")
async def startup():
    await prisma_client.connect()


@app.on_event("shutdown")
async def shutdown():
    await prisma_client.disconnect()


# ルーターを登録
app.include_router(favorites.router, prefix="/api/favorites", tags=["favorites"])
app.include_router(recipes.router, prefix="/api/recipes", tags=["recipes"])
app.include_router(user.router, prefix="/api", tags=["user"])


# ルートパス
@app.get("/")
async def root():
    return {"message": "Recipe App API"}


# ヘルスチェックAPI
@app.get("/health")
async def health_check():
    return {"status": "healthy"}
</file>

<file path="frontend/src/app/login/page.tsx">
'use client';

import Image from 'next/image';
import GoogleLoginButton from '@/components/GoogleLoginButton';

export default function LoginPage() {
  return (
    <div className="flex flex-col items-center justify-center min-h-screen bg-orange-50 px-2">
      <div className="w-full max-w-[350px] sm:max-w-[400px] bg-white rounded-2xl shadow-md border border-orange-100 py-10 px-4 flex flex-col items-center">
        <h1 className="text-2xl font-bold text-gray-800 mb-5">ログイン</h1>
        {/* イラスト */}
        <Image
          src="/login-illustration.png"
          alt="ログインイラスト"
          width={140}
          height={140}
          className="mx-auto mb-8"
          style={{ width: 140, height: 140 }}
        />
        <GoogleLoginButton />
      </div>
    </div>
  );
}
</file>

<file path="frontend/src/app/page.tsx">
'use client';

import { useState } from 'react';
import { fetchRecipes } from './api/fetchRecipes';
import RecipeForm from '../components/RecipeForm';
import RecipeList from '../components/RecipeList';
import LoginMenuButton from '../components/LoginMenu';
import { getAuth } from 'firebase/auth';
import { useRouter } from 'next/navigation';
import PopupMessage from '../components/PopupMessage';

type Recipe = {
  title: string;
  instructions: string;
};

export default function Home() {
  const [recipes, setRecipes] = useState<Recipe[]>([]);
  const [loading, setLoading] = useState(false);
  const [error, setError] = useState<string | null>(null);
  const [isSubmitting, setIsSubmitting] = useState(false);

// ポップアップ用 state
  const [popupMessage, setPopupMessage] = useState<string | null>(null);
  const [autoClose, setAutoClose] = useState(true);
  const router = useRouter();

// ポップアップ閉じる関数
  const closePopup = () => {
    setPopupMessage(null);
  };

  const handleSearch = async (ingredients: string[]) => {
    try {
      setLoading(true);
      setError(null);
      
      const result = await fetchRecipes(ingredients.join(', '));
      
      setRecipes(result);
    } catch (err) {
      setError((err as Error).message);
    } finally {
      setLoading(false);
    }
  };

  // お気に入り登録用関数（認証付きPOST）
  const addFavorite = async (recipe: Recipe) => {
      // FirebaseのcurrentUserからIDトークン取得
      const auth = getAuth();
      const user = auth.currentUser;

      if (!user) {
       // 未ログイン時 → tryに入れずここで完結
       setPopupMessage('ログインしてください');
       setAutoClose(true);
       setTimeout(() => {
         router.push('/login');
       }, 3000);
       return;
    }

  // 認証済み → ここからtry
  setIsSubmitting(true);
  try {
    const idToken = await user.getIdToken();

      // 認証付きでfetch
      const response = await fetch('http://localhost:8000/api/favorites', {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
          Authorization: `Bearer ${idToken}`,
        },
        body: JSON.stringify({
          title: recipe.title,
          content: recipe.instructions,
        }),
      });

  if (response.ok) {
        // 成功時
        setPopupMessage('登録できました！');
        setAutoClose(true);
        setTimeout(() => {
          router.push('/favorites');
        }, 3000);
      } else if (response.status === 409) {
        // 重複時
        setPopupMessage('登録済みです');
        setAutoClose(false); // OKボタンで閉じる
      } else {
        const errorData = await response.json();
        throw new Error(`お気に入り登録に失敗しました (${response.status}): ${errorData.detail}`);
      }
    } catch (error) {
      console.error('エラー:', error);
      setError((error as Error).message);
    } finally {
      setIsSubmitting(false);
    }
  };    

  return (
    <div className="min-h-screen bg-white font-sans p-8 flex flex-col items-center gap-6">
      {/* ヘッダー */}
      <div className="w-full flex justify-end">
        <LoginMenuButton />
      </div>

     {/* 中央揃え部分（h1 ＋ フォーム ＋ メッセージ ＋ リスト） */}
      <div className="flex flex-col items-center w-full max-w-md text-center space-y-6">
        <h1 className="text-3xl font-bold text-[#443627]">今日なにつくる？</h1>

     {/* 検索フォーム */}
      <RecipeForm onSearch={handleSearch} />

     {loading && <p>読み込み中...</p>}
     {error && <p className="text-red-500">{error}</p>}

    {/* レシピリスト */}
      <RecipeList
        recipes={recipes}
        addFavorite={addFavorite}
        isSubmitting={isSubmitting}
      />
    </div>
      
      {/* ★★★ ポップアップ表示 */}
      {popupMessage && (
        <PopupMessage
          message={popupMessage}
          onClose={closePopup}
          autoClose={autoClose}
          autoCloseDelay={3000}
        />
      )}
    </div>
  );
}
</file>

<file path="frontend/package.json">
{
  "name": "next",
  "version": "0.1.0",
  "private": true,
  "scripts": {
    "dev": "next dev",
    "prettier": "prettier --write .",
    "lint": "eslint . --fix",
    "build": "next build",
    "start": "next start",
    "test": "vitest"
  },
  "dependencies": {
    "firebase": "^11.8.1",
    "next": "15.3.3",
    "react": "^19.0.0",
    "react-dom": "^19.0.0",
    "react-firebase-hooks": "^5.1.1",
    "react-hot-toast": "^2.5.2"
  },
  "devDependencies": {
    "@eslint/eslintrc": "^3.0.0",
    "@testing-library/jest-dom": "^6.6.3",
    "@testing-library/react": "^16.3.0",
    "@testing-library/user-event": "^14.6.1",
    "@types/node": "^20.0.0",
    "@types/react": "^19.0.0",
    "@types/react-dom": "^19.0.0",
    "@typescript-eslint/eslint-plugin": "^6.13.1",
    "@typescript-eslint/parser": "^6.13.1",
    "autoprefixer": "^10.4.21",
    "eslint": "^8.56.0",
    "eslint-config-airbnb": "^19.0.4",
    "eslint-config-airbnb-typescript": "^17.1.0",
    "eslint-config-next": "^15.3.3",
    "eslint-config-prettier": "^9.1.0",
    "eslint-import-resolver-typescript": "^4.4.1",
    "eslint-plugin-import": "^2.31.0",
    "eslint-plugin-jsx-a11y": "^6.7.1",
    "eslint-plugin-prettier": "^5.0.1",
    "eslint-plugin-react": "^7.33.2",
    "eslint-plugin-react-hooks": "^4.6.0",
    "jsdom": "^26.1.0",
    "postcss": "^8.5.4",
    "prettier": "^3.2.5",
    "tailwindcss": "^3.4.17",
    "typescript": "^5.3.3",
    "vitest": "^3.1.4"
  }
}
</file>

</files>
